#!/bin/bash
# post-commit hook - Cleans up workflow state and triggers changelog
# Install to: .git/hooks/post-commit

set -e

# Configuration
WORKFLOW_STATE=".workflow_state"
WORKFLOW_ARCHIVE=".workflow_archive"
WORKFLOW_SCRIPTS="scripts/workflow-enforcement"
CHANGELOG="CHANGELOG.md"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${GREEN}[POST-COMMIT]${NC} $1"
}

info() {
    echo -e "${BLUE}[POST-COMMIT]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[POST-COMMIT]${NC} $1"
}

# Archive the workflow state for audit
archive_workflow() {
    if [ ! -f "$WORKFLOW_STATE" ]; then
        return
    fi

    mkdir -p "$WORKFLOW_ARCHIVE"
    local commit_hash=$(git rev-parse HEAD)
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local archive_file="$WORKFLOW_ARCHIVE/workflow_${timestamp}_${commit_hash:0:8}.json"

    # Create JSON archive with commit info
    cat > "$archive_file" <<EOF
{
    "commit_hash": "$commit_hash",
    "commit_message": "$(git log -1 --pretty=%B)",
    "commit_author": "$(git log -1 --pretty=%an)",
    "commit_date": "$(git log -1 --pretty=%ai)",
    "workflow_state": $(cat "$WORKFLOW_STATE" | sed 's/=/": "/g' | sed 's/^/    "/g' | sed 's/$/",/g' | sed '$ s/,$//')
}
EOF

    info "Workflow archived to: $archive_file"
}

# Update changelog if needed
update_changelog() {
    local commit_msg=$(git log -1 --pretty=%B)
    local commit_type=""
    local commit_scope=""
    local commit_subject=""

    # Parse conventional commit format
    if [[ "$commit_msg" =~ ^([a-z]+)(\(([^)]+)\))?: (.+)$ ]]; then
        commit_type="${BASH_REMATCH[1]}"
        commit_scope="${BASH_REMATCH[3]}"
        commit_subject="${BASH_REMATCH[4]}"

        # Determine changelog section
        local section=""
        case "$commit_type" in
            feat)
                section="Added"
                ;;
            fix)
                section="Fixed"
                ;;
            docs)
                section="Documentation"
                ;;
            refactor|perf)
                section="Changed"
                ;;
            security)
                section="Security"
                ;;
            *)
                # Skip changelog for other types (test, chore, etc.)
                return
                ;;
        esac

        # Check if CHANGELOG.md exists
        if [ ! -f "$CHANGELOG" ]; then
            cat > "$CHANGELOG" <<EOF
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### $section
- $commit_subject

EOF
            log "Created new CHANGELOG.md"
        else
            # Check if we have an [Unreleased] section
            if ! grep -q "## \[Unreleased\]" "$CHANGELOG"; then
                # Add Unreleased section after the header
                sed -i.bak '/^# Changelog/a\\n## [Unreleased]\n' "$CHANGELOG"
            fi

            # Check if we have the section for this commit type
            if ! sed -n '/## \[Unreleased\]/,/## \[/p' "$CHANGELOG" | grep -q "### $section"; then
                # Add the section
                sed -i.bak "/## \[Unreleased\]/a\\\\n### $section" "$CHANGELOG"
            fi

            # Add the commit to the appropriate section
            # Find the line number of the section
            local section_line=$(grep -n "### $section" "$CHANGELOG" | head -1 | cut -d: -f1)
            if [ -n "$section_line" ]; then
                # Insert the commit message after the section header
                sed -i.bak "${section_line}a\\- $commit_subject" "$CHANGELOG"
                log "Updated CHANGELOG.md - $section: $commit_subject"
            fi
        fi

        # Clean up backup files
        rm -f "${CHANGELOG}.bak"
    fi
}

# Clean up workflow state
cleanup_workflow() {
    if [ -f "$WORKFLOW_STATE" ]; then
        # Update state to completed
        if [ -f "$WORKFLOW_SCRIPTS/workflow_state_manager.sh" ]; then
            "$WORKFLOW_SCRIPTS/workflow_state_manager.sh" update -p GIT_OPERATIONS -s COMPLETED 2>/dev/null || true
        fi

        # Archive before removing
        archive_workflow

        # Remove the state file
        rm -f "$WORKFLOW_STATE"
        log "Workflow state cleaned up"
    fi
}

# Check for post-commit review requirement
check_review_requirement() {
    if [ -f ".workflow_bypass_log" ]; then
        local bypass_count=$(wc -l < .workflow_bypass_log)
        if [ "$bypass_count" -gt 0 ]; then
            warning "⚠️  ATTENTION: $bypass_count emergency bypass(es) used"
            warning "Please schedule post-commit review for bypassed commits:"
            cat .workflow_bypass_log
            echo ""
        fi
    fi
}

# Generate commit summary
show_commit_summary() {
    local commit_hash=$(git rev-parse HEAD)
    local commit_msg=$(git log -1 --pretty=%B | head -1)
    local files_changed=$(git diff HEAD^ --name-only | wc -l)

    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    log "Commit successful!"
    echo ""
    echo "  Hash:    ${commit_hash:0:8}"
    echo "  Message: $commit_msg"
    echo "  Files:   $files_changed changed"
    echo ""

    # Show next steps
    echo "  Next steps:"
    echo "    • Push to remote:  git push origin $(git branch --show-current)"
    echo "    • Create PR:       gh pr create"
    echo "    • View status:     git status"
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo ""
}

# Main post-commit workflow
main() {
    # Update changelog
    update_changelog

    # Clean up workflow state
    cleanup_workflow

    # Check for review requirements
    check_review_requirement

    # Show summary
    show_commit_summary
}

# Run main function
main "$@"